# Требования к ПО и оборудованию
Для обеспечения автономности компонентов стенда развертывание соответствующих приложений осуществляется с использованием платформы контейнеризации на базе ПО Docker. Развертывание Docker осуществляется на хосте под управлением ОС Debian 11 в соответствии с [инструкцией](Развертывание%20Docker%20под%20Debian%2011.md). Рекомендуемые аппаратные характеристики:
- 4 x vCPU
- 16 Gb RAM
- 80 Gb HDD
После установки Docker необходимо создать внутреннюю сеть `ptdemo-bridge` в соответствии с командой, представленной на [этой](Создание%20подсети%20Docker.md) странице. В дальнейшем именно эта сеть будет указываться при создании контейнеров.
# Состав вспомогательных компонентов стенда
В настоящее время веб-интерфейс стал стандартом де-факто для обеспечения взаимодействия пользователей с приложениями. При этом очевидным образом возникает задача обеспечения защиты трафика между браузером пользователя и веб-приложением. Несмотря на то, что во многих приложениях сохраняется возможность индивидуального конфигурирования настроек SSL с указанием сертификата и закрытого ключа сервера, все чаще решение этой задачи отдается на откуп обратному прокси-серверу, развернутому перед одним или несколькими приложениями и перенаправляющему трафик в соответствии с тем, какое имя сервера использовалось в запросе. В этой ситуации трафик между прокси-сервером и приложением передается в открытом виде что накладывает определенные требования в плане необходимости предотвращения возможности его перехвата. При использовании Docker эта задача решается размещением обратного прокси-сервера и приложения в отдельной сети Docker, при этом из внешней сети остается доступен только сетевой порт прокси. 
Таким образом, при подготовке к развертыванию стенда, помимо установки ОС Debian 11 и ПО Docker необходимо выполнить установку следующих компонентов:
- локальный DNS-сервер Bind;
- набор утилит для выпуска сертификатов, соответствующих классической двухуровневой структуре удостоверяющего центра;
- ПО Portainer для обеспечения удобства управления Docker посредством веб-интерфейса;
- Веб-сервер NGINX, функционирующий в режиме обратного прокси-сервера
# Развертывание локального DNS-сервера Bind9
Использование обратного прокси-сервера для обеспечения прозрачной поддержки HTTPS компонентами стенда означает, что определение того, куда будет перенаправлен запрос пользователя, осуществляется на основании используемого в URL запроса DNS-имени хоста. В этой ситуации необходимо обеспечить возможность преобразования DNS-имен в IP-адреса, что, как правило, обеспечивается посредством настроек DNS-сервера. Однако, при создании макета не всегда существует возможность оперативного создания соответствующих учетных записей, а распространенная практика с указанием соответствия DNS-имени и IP-адреса в файле hosts [неприменима](https://docs.docker.com/network/#custom-hosts) в инфраструктуре, основанной на контейнеризации, частным примером которой являются AppSec решения.
В этой ситуации выходом может послужить развертывание локального DNS-сервера на базе Bind. Установка и конфигурирование указанного ПО осуществляется в соответствии с [инструкцией](Bind.md)
# Выпуск сертификатов
Для обеспечения защиты HTTP-трафика между компонентами стенда используется стандартный протокол SSL, для функционирования которого необходимо обеспечить наличие закрытого ключа и сертификата сервера. Как правило, инструкции, описывающие процедуру генерации, сводятся к выпуску самоподписанного сертификата, однако такой подход не является типовым при работе в реальной инфраструктуре. Вместо самоподписанных, как правило, применяется подход с двухуровневым центром сертификации, состоящим из двух удостоверяющих центров: корневого и выпускающего, сертификаты которых устанавливаются в качестве доверенных. После этого необходимо сгенерировать закрытый ключ SSL-сервера, сформировать и подписать запрос на выпуск сертификата, указав в нем необходимый набор атрибутов, передать этот запрос на выпускающий УЦ и выпустить сертификат SSL-сервера, подписав его ключом УЦ. Кроме того, в ходе работы может потребоваться экспорт полученных файлов в различные форматы, такие как контейнер PKCS#12, JKS-хранилище для Java-приложений и т.д.

Реализовать такой подход можно и самостоятельно, однако, чтобы избежать ошибок, в рамках нашего мероприятия мы воспользуемся готовым набором скриптов, доступным по [ссылке](https://github.com/ZhukovAN/CA.git).

Для того, чтобы обеспечить изолированность создаваемого  двухуровневого УЦ от ПО, присутствующего на хосте стенда, соответствующие скрипты обёрнуты в Docker-образ, который необходимо собрать в соответствии с инструкцией в README.md-файле в указанном репозитории. В нашем случае мы будем использовать УЦ с именем, соответствующим дате проведения нашего мероприятия:
``` bash
# Загружаем исходный код УЦ
git clone https://github.com/ZhukovAN/CA.git && cd CA
# Собираем образ и помечаем его тегом
docker build \
  --build-arg ORGANIZATION=20240515.LOCAL \
  --tag 20240515/ca:latest .
# Создаем локальные каталоги Docker, в которых будут сохраняться файлы УЦ для сохранения состояния между перезапусками
docker volume create 20240515-ca-conf
docker volume create 20240515-ca-data
# Запускаем контейнер без параметров. При этом будет проведена проверка наличия закрытых ключей в соответствующих каталогах и при их отсутствии будет выполнена генерация ключей и сертификатов корневого и выпускающего УЦ с именем, соответствующим значению переменной ORGANIZATION, указанной при сборке образа
docker run --rm -it \
  --volume 20240515-ca-conf:/opt/ca/conf \
  --volume 20240515-ca-data:/opt/ca/data \
  20240515/ca:latest
# Запускаем контейнер в режиме выпуска сертификата SSL-сервера
docker run --rm -it \
  --volume 20240515-ca-conf:/opt/ca/conf \
  --volume 20240515-ca-data:/opt/ca/data \
  20240515/ca:latest \
  generateSslServerCertificate DNS:*.20240515.local
```
Итогом наших действий станет появление в каталоге `/var/lib/docker/volumes` подкаталогов `20240515-ca-conf` и `20240515-ca-data`, содержащих файлы созданного двухуровневого УЦ. Также отметим, что при выпуске сертификата SSL-сервера мы указали DNS-имя, содержащее маску имени хоста что позволит применять один и тот же сертификат для всех разворачиваемых серверов, входящих в состав домена 20240515.local. 
Сертификаты корневого и выпускающего УЦ должны быть установлены в качестве доверенных на всех хостах, с которых будет осуществляться взаимодействие с компонентами стенда, в т.ч. и на самом хосте сервера:
``` bash
cp /var/lib/docker/volumes/20240515-ca-data/_data/root-ca/certs/ca.pem /usr/local/share/ca-certificates/20240515-root-ca.crt
cp /var/lib/docker/volumes/20240515-ca-data/_data/intermediate-ca/certs/ca.pem /usr/local/share/ca-certificates/20240515-intermediate-ca.crt
update-ca-certificates
```
Для удобства дальнейшей работы можно скопировать ключ и сертификат SSL-сервера на локальный хост, например, с использованием Far Manager или аналогичной утилиты, позволяющей работать с удаленной файловой системой по протоколу SFTP, функционирующему поверх SSH.
![Pasted image 20240314102536 1](Pasted%20image%2020240314102536%201.png)
![Pasted image 20240314102624 1](Pasted%20image%2020240314102624%201.png)
# Развертывание Portainer
Для большей наглядности применительно к тому, что происходит в Docker-контейнерах, развернем в Docker утилиту Portainer, предоставляющую веб-интерфейс для работы с Docker. Разворачивание осуществляется в соответствии с [инструкцией](Portainer.md). После установки веб-интерфейс Portainer станет доступным по адресу [https://demo.20240515.local:9443/](https://demo.20240515.local:9443/) при переходе по которому у нас появляется возможность установить пароль администратора.
После аутентификации в Portainer у нас появится возможность сменить ключ и сертификат, используемые для реализации SSL, в качестве которых мы используем `key.pem` и `server.pem`, соответственно:
![Pasted image 20240314102938 1](Pasted%20image%2020240314102938%201.png)
После внесения и активации изменений можно убедиться в том, что для HTTPS-соединения используется сертификат, выпущенный нашим УЦ:
![Pasted image 20240314103227 1](Pasted%20image%2020240314103227%201.png)
# Развертывание обратного прокси-сервера NGINX

Как было отмечено выше, решение о том, куда будет перенаправлен запрос пользователя осуществляется на основании DNS-имени хоста, что означает, что доступ к приложению должен осуществляться по имени хоста, а не по его IP-адресу.
Разворачивание прокси-сервера NGINX осуществляется в соответствии с [инструкцией](NGINX.md), в которую необходимо внести некоторые изменения, относящиеся к фактическому расположению каталога с закрытым ключом и сертификатом SSL-сервера:
``` bash
docker cp /var/lib/docker/volumes/20240515-ca-data/_data/intermediate-ca/out/F8BE4182D21D4C68/server.pem nginx:/etc/nginx/ssl/nginx.crt
docker cp /var/lib/docker/volumes/20240515-ca-data/_data/intermediate-ca/out/F8BE4182D21D4C68/key.pem nginx:/etc/nginx/ssl/nginx.key
```
По итогам ее выполнения в нашем Docker будет развернут контейнер, порты 80 и 443 которого привязаны к портам хоста. При этом NGINX будет запущен в режиме работы только по протоколу HTTP с использованием порта 80:
![Pasted image 20240314112453](Pasted%20image%2020240314112453.png)
Также, в каталог `/etc/nginx/ssl/` контейнера будут скопированы файлы ключа и сертификата SSL-сервера, которые будет использовать NGINX.

Отметим, что на текущий момент NGINX еще не сконфигурирован в качестве обратного прокси-сервера: такая настройка выполняется индивидуально для каждой системы, находящейся за ним. В рамках нашего мероприятия мы будем использовать для такого конфигурирования подход, связанный с сохранением в каталог `/etc/nginx/conf.d`  конфигурационных файлов, соответствующих подключаемой системе с последующим перезапуском контейнера NGINX